package fibonacci

import (
	"testing"
)

func BenchmarkFibonacciOriginal(b *testing.B) {
	for i := 0; i < b.N; i++ {
		FibonacciOriginal(20) // Adjust the input value as needed
	}
}

func BenchmarkFibonacciOptimized(b *testing.B) {
	for i := 0; i < b.N; i++ {
		FibonacciOptimized(20) // Adjust the input value as needed
	}
}

// "37710"과 "25000155"라는 숫자는 벤치마크 결과에서 각각의 벤치마크 함수당 1초에 실행된 작업 횟수(초당 반복 횟수)를 나타냅니다.
// 이러한 숫자들은 벤치마크 동안 코드가 1초 동안 얼마나 많이 실행되었는지를 나타내며, 함수의 성능을 나타냅니다.

// BenchmarkFibonacciOriginal-12 함수는 대략 37,710번의 반복을 1초에 실행했습니다.
// BenchmarkFibonacciOptimized-12 함수는 대략 25,000,155번의 반복을 1초에 실행했습니다.
// 이러한 값들은 다른 구현체들의 상대적인 성능을 비교하는 데에 도움이 될 수 있습니다.
// 이 경우 최적화된 피보나치 함수 구현(FibonacciOptimized)이 월등히 빠르며, 1초에 약 2500만 번의 반복을 수행할 수 있으며,
//  원래의 구현(FibonacciOriginal)은 대략 3만 7,710번의 반복을 1초에 수행할 수 있습니다.

// 이러한 숫자들은 기계의 성능, 부하, 그리고 다른 실행 중인 프로세스 등의 영향을 받아 다른 시스템에서 다를 수 있습니다.
// 그러나 이 값들은 여전히 다른 코드 구현체 또는 최적화의 성능을 비교하는 유용한 방법을 제공합니다. 벤치마크 결과에서는 값이 작을수록(즉, 초당 반복 횟수가 많을수록) 실행 시간이 더 빠른 것을 의미합니다.

// "allocs/op"은 벤치마크 동안 각 작업(반복)당 수행된 평균 메모리 할당 횟수를 나타냅니다. 이 지표는 메모리 할당 동작이 코드의 성능에 어떤 영향을 미칠 수 있는지 이해하는 데 도움이 됩니다.

// BenchmarkFibonacciOriginal-12에서는 평균적으로 작업 당 메모리 할당이 없어서 0 B/op로 표시됩니다. 이는 원래의 구현에서 재귀를 사용하며 실행 중에 새로운 데이터 구조를 생성하지 않기 때문입니다.
// BenchmarkFibonacciOptimized-12에서는 평균적으로 작업 당 176바이트의 메모리 할당이 있어서 176 B/op로 표시됩니다. 이 메모리 할당은 중간 결과를 계산하는 동안 생성된 배열(fib) 때문일 가능성이 있습니다.
// 다음은 이러한 숫자들이 나타내는 바입니다:

// 0 B/op: FibonacciOriginal의 경우, 원래 구현에서는 메모리 할당이 감지되지 않았습니다. 이는 원래 구현이 재귀를 사용하며 실행 중에 새로운 데이터 구조를 생성하지 않기 때문입니다.
// 176 B/op: FibonacciOptimized의 경우, 최적화된 구현에서는 평균적으로 작업 당 176바이트의 메모리 할당이 있었습니다. 이 메모리 할당은 계산 중간 결과를 저장하기 위해 배열(fib)을 생성하는 데 기인할 것입니다.
// "allocs/op"이 낮을수록 좋은데, 이는 코드에서 메모리 할당을 적게 사용한다는 것을 의미하며, 이는 전체적인 성능 향상과 메모리 부담 감소로 이어질 수 있습니다.

// 메모리 할당을 최소화하는 것은 성능에 도움이 되지만, 코드 복잡성과 가독성과의 균형도 고려해야 합니다. 경우에 따라 약간 더 높은 메모리 할당도 허용될 수 있습니다. 이러한 할당이 성능에 큰 향상을 가져온다면 허용할 만한 트레이드오프가 될 수 있습니다.

// 피보나치 예제를 통해 논의한 성능 관련 문제는 실제로 Go의 프로파일링과 관련이 있습니다. 프로파일링은 코드의 성능을 측정하고 병목 현상을 찾아내며 CPU 사용률, 메모리 할당 등 다양한 측면을 분석하는 과정입니다. 프로파일링의 목표는 코드의 실행 성능을 이해하고 효율적인 최적화를 위해 코드를 분석하는 것입니다.

// 원래의 질문에 대한 답변으로, Go의 테스팅 및 벤치마킹 도구를 사용할 때 프로파일링은 코드의 성능 특성을 파악하는 데에 관련이 있습니다. 프로파일링 도구를 사용하면 코드가 가장 많은 시간을 소비하는 부분, 메모리가 어디에 할당되는지 등 성능과 관련된 다양한 정보를 파악할 수 있습니다. 특히 코드를 최적화하고 효율성을 향상시키기 위해 유용합니다.

// Go는 pprof 패키지와 같은 내장된 프로파일링 도구를 제공하며, CPU 프로파일, 메모리 프로파일 등 다양한 종류의 프로파일을 생성하는 데 사용할 수 있습니다. 이 도구를 테스트와 벤치마크와 함께 사용하여 성능 문제를 식별하고 최적화의 영향을 측정하며, 코드의 성능을 향상시키는 데에 도움이 됩니다.

// 요약하자면, 프로파일링은 Go에서 성능 최적화의 필수 요소이며, 재귀와 함수 호출 오버헤드와 관련된 문제를 이해하고 해결하는 데에 도움을 줄 수 있습니다.
